---
id: 4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a
blueprint: blog
title: 'Git Workflow: How I Manage Code Like a Pro'
excerpt: "From messy commits to clean history‚Äîhere's the Git workflow that saved my sanity and made code reviews actually enjoyable. Branch strategies, commit conventions, and automation tips."
thumbnail: 20251003_1217_git-workflow-editor_simple_compose_01k6m4k5x1f9r8nmq2wsq0519s.png
author: 6bf600cc-d3af-47af-acec-186dd6738b62
template: page/blog/details
date: '2025-02-01'
reading_time: 11
is_featured: false
is_published: true
enable_comments: true
meta_description: 'Professional Git workflow guide covering branching strategies, commit conventions, PR best practices, and automation for clean, maintainable codebases.'
focus_keyword: 'Git Workflow'
categories: development
tags:
  - git
  - workflow
  - devops
updated_by: 6bf600cc-d3af-47af-acec-186dd6738b62
updated_at: 1759465108
---
## The Problem with "Just Git"

Early in my career, my Git history looked like this:

```
* fix bug
* wip
* asdfasdf
* FINALLY WORKS
* plz work
* one more try
```

Sound familiar? We've all been there. But messy Git history isn't just embarrassing‚Äîit makes debugging, collaboration, and code archaeology nearly impossible.

Here's the workflow that transformed my development process.

## Branch Strategy: Git Flow (Simplified)

I use a simplified Git Flow that works for small teams and solo projects:

```
main (production)
  ‚Üì
develop (staging/integration)
  ‚Üì
feature/user-authentication
feature/blog-pagination
bugfix/header-overflow
hotfix/security-patch
```

**Branch naming convention:**
- `feature/*` - New features
- `bugfix/*` - Bug fixes
- `hotfix/*` - Urgent production fixes
- `refactor/*` - Code refactoring
- `docs/*` - Documentation updates

### Why This Works

1. **`main` is always deployable** - Production-ready code only
2. **`develop` is integration** - Feature branches merge here first
3. **Feature isolation** - Work on features without breaking anything
4. **Clear intent** - Branch names document what you're working on

## Commit Message Convention: Conventional Commits

I follow [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `style:` - Code style (formatting, missing semicolons)
- `refactor:` - Code refactoring
- `test:` - Adding or updating tests
- `chore:` - Maintenance tasks

**Examples:**

```bash
# Simple commit
git commit -m "feat(auth): add password reset functionality"

# Detailed commit with body
git commit -m "fix(api): resolve rate limiting for authenticated users

The rate limiter was incorrectly applying guest limits to
authenticated users. Updated middleware to check auth status
before applying rate limits.

Fixes #123"
```

**Benefits:**
- Auto-generate changelogs
- Semantic versioning automation
- Clear commit history
- Easy to search (`git log --grep="feat(auth)"`)

## Atomic Commits: One Change, One Commit

Each commit should represent **one logical change**:

```bash
# ‚ùå Bad - Multiple unrelated changes
git add .
git commit -m "fix login and add new blog feature"

# ‚úÖ Good - Separate commits
git add src/auth/login.js
git commit -m "fix(auth): prevent double login submission"

git add src/blog/create.js src/blog/routes.js
git commit -m "feat(blog): add blog creation form"
```

### Interactive Staging for Precision

Stage specific lines with `git add -p`:

```bash
git add -p src/components/Header.js

# Git will show hunks and ask:
# Stage this hunk [y,n,q,a,d,s,e,?]?

# y - Yes, stage this hunk
# n - No, don't stage
# s - Split into smaller hunks
# e - Manually edit the hunk
```

This lets you create perfect atomic commits even when you've made multiple changes in one file.

## Pull Request Workflow

### 1. Create Feature Branch from `develop`

```bash
git checkout develop
git pull origin develop
git checkout -b feature/user-profile
```

### 2. Work and Commit Regularly

```bash
# Make changes
git add src/profile/
git commit -m "feat(profile): add user profile page"

# More changes
git add src/profile/avatar.js
git commit -m "feat(profile): add avatar upload"
```

### 3. Keep Branch Updated

```bash
# Rebase on develop to avoid merge conflicts later
git fetch origin
git rebase origin/develop

# If conflicts occur, resolve them:
git status
# Fix conflicts in files
git add .
git rebase --continue
```

### 4. Clean Up History Before PR

```bash
# Interactive rebase to squash/reorder commits
git rebase -i origin/develop

# Editor opens:
# pick abc123 feat(profile): add user profile page
# squash def456 feat(profile): fix typo
# squash ghi789 feat(profile): add avatar upload

# Result: Clean, atomic commits
```

### 5. Push and Create PR

```bash
git push origin feature/user-profile

# Use GitHub CLI for faster PR creation
gh pr create --title "Add user profile page" --body "Implements user profile with avatar upload. Resolves #45"
```

## Git Aliases: Speed Up Your Workflow

Add to `~/.gitconfig`:

```ini
[alias]
  # Quick status
  st = status -sb

  # Pretty log
  lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit

  # Amend last commit without editing message
  amend = commit --amend --no-edit

  # Undo last commit but keep changes
  undo = reset HEAD~1 --soft

  # Stash with message
  save = stash push -m

  # Quick checkout
  co = checkout

  # Quick branch
  br = branch

  # Pull with rebase
  up = pull --rebase origin

  # Push current branch
  publish = push -u origin HEAD

  # Delete merged branches
  cleanup = "!git branch --merged | grep -v '\\*\\|main\\|develop' | xargs -n 1 git branch -d"
```

Now use them:

```bash
git st              # Instead of git status
git lg              # Beautiful commit history
git amend           # Quick amend
git save "wip"      # Stash with message
git cleanup         # Delete merged branches
```

## Git Hooks: Automate Quality Checks

Use [Husky](https://typicode.github.io/husky/) for Git hooks:

```bash
npm install --save-dev husky
npx husky install
```

### Pre-commit Hook: Lint and Format

```bash
npx husky add .husky/pre-commit "npm run lint"
```

`.husky/pre-commit`:
```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npm run lint
npm run format
```

### Commit Message Hook: Enforce Convention

```bash
npx husky add .husky/commit-msg "npx --no -- commitlint --edit $1"
```

Install commitlint:

```bash
npm install --save-dev @commitlint/cli @commitlint/config-conventional
```

`commitlint.config.js`:
```javascript
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore',
    ]],
  },
};
```

Now invalid commits are blocked:

```bash
git commit -m "added stuff"
# ‚ùå Error: subject may not be empty [subject-empty]

git commit -m "feat(blog): add pagination"
# ‚úÖ Passes
```

## Resolving Merge Conflicts Like a Pro

When conflicts happen:

```bash
# See which files have conflicts
git status

# For each conflicted file:
# 1. Open file and look for conflict markers:
<<<<<<< HEAD
Your changes
=======
Their changes
>>>>>>> branch-name

# 2. Resolve manually, or use a merge tool:
git mergetool

# 3. Stage resolved files:
git add resolved-file.js

# 4. Complete the merge:
git commit
```

**Pro tip:** Use VS Code's merge conflict interface‚Äîit's excellent.

## Advanced: Interactive Rebase Mastery

Rewrite history with `git rebase -i`:

```bash
git rebase -i HEAD~5  # Edit last 5 commits
```

**Commands:**
- `pick` - Keep commit as-is
- `reword` - Change commit message
- `edit` - Pause to amend commit
- `squash` - Combine with previous commit
- `fixup` - Like squash, but discard message
- `drop` - Delete commit

**Example workflow:**

```
pick abc123 feat(blog): add blog list
fixup def456 fix typo
pick ghi789 feat(blog): add pagination
reword jkl012 feat(blog): add search
```

Result: Clean, professional commit history.

## Git Stash: Your Safety Net

Save work without committing:

```bash
# Stash changes
git stash

# Stash with message
git stash push -m "WIP: refactoring auth"

# List stashes
git stash list

# Apply most recent stash
git stash apply

# Apply and remove from stash list
git stash pop

# Apply specific stash
git stash apply stash@{2}

# Create branch from stash
git stash branch feature/new-auth stash@{0}
```

## When Things Go Wrong: Recovery Commands

### Undo Last Commit (Keep Changes)

```bash
git reset HEAD~1 --soft
```

### Undo Last Commit (Discard Changes)

```bash
git reset HEAD~1 --hard
```

### Recover Deleted Commit

```bash
git reflog  # Find commit hash
git cherry-pick <hash>
```

### Undo Pushed Commit (Safe)

```bash
git revert <commit-hash>
git push
```

### Reset to Remote State

```bash
git fetch origin
git reset --hard origin/main
```

## Workflow Checklist

Before every PR:

- ‚úÖ Branch name follows convention
- ‚úÖ Commits are atomic and well-named
- ‚úÖ Rebased on latest `develop`
- ‚úÖ Tests pass locally
- ‚úÖ No merge conflicts
- ‚úÖ Code is linted and formatted
- ‚úÖ PR description is clear

## Tools I Use Daily

- **GitHub CLI (`gh`)** - Create PRs from terminal
- **Husky** - Git hooks automation
- **Commitlint** - Enforce commit conventions
- **Git GUI** - VS Code's Git integration
- **Lazygit** - Terminal UI for Git

## Conclusion

A solid Git workflow isn't about memorizing commands‚Äîit's about:
1. **Intentional commits** - Each commit tells a story
2. **Clean history** - Easy to review and debug
3. **Collaboration** - PRs are smooth and conflict-free
4. **Automation** - Hooks catch mistakes before they're committed

Start with branch naming and commit conventions. Add aliases for speed. Implement hooks for quality. Before you know it, your Git history will be something you're proud to show.

Happy committing! üöÄ

---

**Resources:**
- [Conventional Commits](https://www.conventionalcommits.org/)
- [Git Documentation](https://git-scm.com/doc)
- [Atlassian Git Tutorials](https://www.atlassian.com/git/tutorials)
- [Oh Shit, Git!?!](https://ohshitgit.com/)